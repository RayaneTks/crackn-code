
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/*
 * This file exports the `personalisation` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/library"
import type * as $Enums from "../enums.js"
import type * as Prisma from "../internal/prismaNamespace.js"

/**
 * Model personalisation
 * 
 */
export type personalisationModel = runtime.Types.Result.DefaultSelection<Prisma.$personalisationPayload>

export type AggregatePersonalisation = {
  _count: PersonalisationCountAggregateOutputType | null
  _min: PersonalisationMinAggregateOutputType | null
  _max: PersonalisationMaxAggregateOutputType | null
}

export type PersonalisationMinAggregateOutputType = {
  id_user: string | null
  accessories: string | null
  hat_colors: string | null
  hair_colors: string | null
  facial_hair_types: string | null
  facial_hair_colors: string | null
  clothes: string | null
  clothes_colors: string | null
  graphics: string | null
  eyes: string | null
  eyebrows: string | null
  skin_colors: string | null
}

export type PersonalisationMaxAggregateOutputType = {
  id_user: string | null
  accessories: string | null
  hat_colors: string | null
  hair_colors: string | null
  facial_hair_types: string | null
  facial_hair_colors: string | null
  clothes: string | null
  clothes_colors: string | null
  graphics: string | null
  eyes: string | null
  eyebrows: string | null
  skin_colors: string | null
}

export type PersonalisationCountAggregateOutputType = {
  id_user: number
  accessories: number
  hat_colors: number
  hair_colors: number
  facial_hair_types: number
  facial_hair_colors: number
  clothes: number
  clothes_colors: number
  graphics: number
  eyes: number
  eyebrows: number
  skin_colors: number
  _all: number
}


export type PersonalisationMinAggregateInputType = {
  id_user?: true
  accessories?: true
  hat_colors?: true
  hair_colors?: true
  facial_hair_types?: true
  facial_hair_colors?: true
  clothes?: true
  clothes_colors?: true
  graphics?: true
  eyes?: true
  eyebrows?: true
  skin_colors?: true
}

export type PersonalisationMaxAggregateInputType = {
  id_user?: true
  accessories?: true
  hat_colors?: true
  hair_colors?: true
  facial_hair_types?: true
  facial_hair_colors?: true
  clothes?: true
  clothes_colors?: true
  graphics?: true
  eyes?: true
  eyebrows?: true
  skin_colors?: true
}

export type PersonalisationCountAggregateInputType = {
  id_user?: true
  accessories?: true
  hat_colors?: true
  hair_colors?: true
  facial_hair_types?: true
  facial_hair_colors?: true
  clothes?: true
  clothes_colors?: true
  graphics?: true
  eyes?: true
  eyebrows?: true
  skin_colors?: true
  _all?: true
}

export type PersonalisationAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which personalisation to aggregate.
   */
  where?: Prisma.personalisationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of personalisations to fetch.
   */
  orderBy?: Prisma.personalisationOrderByWithRelationInput | Prisma.personalisationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.personalisationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` personalisations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` personalisations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned personalisations
  **/
  _count?: true | PersonalisationCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: PersonalisationMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: PersonalisationMaxAggregateInputType
}

export type GetPersonalisationAggregateType<T extends PersonalisationAggregateArgs> = {
      [P in keyof T & keyof AggregatePersonalisation]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregatePersonalisation[P]>
    : Prisma.GetScalarType<T[P], AggregatePersonalisation[P]>
}




export type personalisationGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.personalisationWhereInput
  orderBy?: Prisma.personalisationOrderByWithAggregationInput | Prisma.personalisationOrderByWithAggregationInput[]
  by: Prisma.PersonalisationScalarFieldEnum[] | Prisma.PersonalisationScalarFieldEnum
  having?: Prisma.personalisationScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: PersonalisationCountAggregateInputType | true
  _min?: PersonalisationMinAggregateInputType
  _max?: PersonalisationMaxAggregateInputType
}

export type PersonalisationGroupByOutputType = {
  id_user: string
  accessories: string | null
  hat_colors: string | null
  hair_colors: string | null
  facial_hair_types: string | null
  facial_hair_colors: string | null
  clothes: string | null
  clothes_colors: string | null
  graphics: string | null
  eyes: string | null
  eyebrows: string | null
  skin_colors: string | null
  _count: PersonalisationCountAggregateOutputType | null
  _min: PersonalisationMinAggregateOutputType | null
  _max: PersonalisationMaxAggregateOutputType | null
}

type GetPersonalisationGroupByPayload<T extends personalisationGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<PersonalisationGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof PersonalisationGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], PersonalisationGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], PersonalisationGroupByOutputType[P]>
      }
    >
  >



export type personalisationWhereInput = {
  AND?: Prisma.personalisationWhereInput | Prisma.personalisationWhereInput[]
  OR?: Prisma.personalisationWhereInput[]
  NOT?: Prisma.personalisationWhereInput | Prisma.personalisationWhereInput[]
  id_user?: Prisma.StringFilter<"personalisation"> | string
  accessories?: Prisma.StringNullableFilter<"personalisation"> | string | null
  hat_colors?: Prisma.StringNullableFilter<"personalisation"> | string | null
  hair_colors?: Prisma.StringNullableFilter<"personalisation"> | string | null
  facial_hair_types?: Prisma.StringNullableFilter<"personalisation"> | string | null
  facial_hair_colors?: Prisma.StringNullableFilter<"personalisation"> | string | null
  clothes?: Prisma.StringNullableFilter<"personalisation"> | string | null
  clothes_colors?: Prisma.StringNullableFilter<"personalisation"> | string | null
  graphics?: Prisma.StringNullableFilter<"personalisation"> | string | null
  eyes?: Prisma.StringNullableFilter<"personalisation"> | string | null
  eyebrows?: Prisma.StringNullableFilter<"personalisation"> | string | null
  skin_colors?: Prisma.StringNullableFilter<"personalisation"> | string | null
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.userWhereInput>
}

export type personalisationOrderByWithRelationInput = {
  id_user?: Prisma.SortOrder
  accessories?: Prisma.SortOrderInput | Prisma.SortOrder
  hat_colors?: Prisma.SortOrderInput | Prisma.SortOrder
  hair_colors?: Prisma.SortOrderInput | Prisma.SortOrder
  facial_hair_types?: Prisma.SortOrderInput | Prisma.SortOrder
  facial_hair_colors?: Prisma.SortOrderInput | Prisma.SortOrder
  clothes?: Prisma.SortOrderInput | Prisma.SortOrder
  clothes_colors?: Prisma.SortOrderInput | Prisma.SortOrder
  graphics?: Prisma.SortOrderInput | Prisma.SortOrder
  eyes?: Prisma.SortOrderInput | Prisma.SortOrder
  eyebrows?: Prisma.SortOrderInput | Prisma.SortOrder
  skin_colors?: Prisma.SortOrderInput | Prisma.SortOrder
  user?: Prisma.userOrderByWithRelationInput
  _relevance?: Prisma.personalisationOrderByRelevanceInput
}

export type personalisationWhereUniqueInput = Prisma.AtLeast<{
  id_user?: string
  AND?: Prisma.personalisationWhereInput | Prisma.personalisationWhereInput[]
  OR?: Prisma.personalisationWhereInput[]
  NOT?: Prisma.personalisationWhereInput | Prisma.personalisationWhereInput[]
  accessories?: Prisma.StringNullableFilter<"personalisation"> | string | null
  hat_colors?: Prisma.StringNullableFilter<"personalisation"> | string | null
  hair_colors?: Prisma.StringNullableFilter<"personalisation"> | string | null
  facial_hair_types?: Prisma.StringNullableFilter<"personalisation"> | string | null
  facial_hair_colors?: Prisma.StringNullableFilter<"personalisation"> | string | null
  clothes?: Prisma.StringNullableFilter<"personalisation"> | string | null
  clothes_colors?: Prisma.StringNullableFilter<"personalisation"> | string | null
  graphics?: Prisma.StringNullableFilter<"personalisation"> | string | null
  eyes?: Prisma.StringNullableFilter<"personalisation"> | string | null
  eyebrows?: Prisma.StringNullableFilter<"personalisation"> | string | null
  skin_colors?: Prisma.StringNullableFilter<"personalisation"> | string | null
  user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.userWhereInput>
}, "id_user">

export type personalisationOrderByWithAggregationInput = {
  id_user?: Prisma.SortOrder
  accessories?: Prisma.SortOrderInput | Prisma.SortOrder
  hat_colors?: Prisma.SortOrderInput | Prisma.SortOrder
  hair_colors?: Prisma.SortOrderInput | Prisma.SortOrder
  facial_hair_types?: Prisma.SortOrderInput | Prisma.SortOrder
  facial_hair_colors?: Prisma.SortOrderInput | Prisma.SortOrder
  clothes?: Prisma.SortOrderInput | Prisma.SortOrder
  clothes_colors?: Prisma.SortOrderInput | Prisma.SortOrder
  graphics?: Prisma.SortOrderInput | Prisma.SortOrder
  eyes?: Prisma.SortOrderInput | Prisma.SortOrder
  eyebrows?: Prisma.SortOrderInput | Prisma.SortOrder
  skin_colors?: Prisma.SortOrderInput | Prisma.SortOrder
  _count?: Prisma.personalisationCountOrderByAggregateInput
  _max?: Prisma.personalisationMaxOrderByAggregateInput
  _min?: Prisma.personalisationMinOrderByAggregateInput
}

export type personalisationScalarWhereWithAggregatesInput = {
  AND?: Prisma.personalisationScalarWhereWithAggregatesInput | Prisma.personalisationScalarWhereWithAggregatesInput[]
  OR?: Prisma.personalisationScalarWhereWithAggregatesInput[]
  NOT?: Prisma.personalisationScalarWhereWithAggregatesInput | Prisma.personalisationScalarWhereWithAggregatesInput[]
  id_user?: Prisma.StringWithAggregatesFilter<"personalisation"> | string
  accessories?: Prisma.StringNullableWithAggregatesFilter<"personalisation"> | string | null
  hat_colors?: Prisma.StringNullableWithAggregatesFilter<"personalisation"> | string | null
  hair_colors?: Prisma.StringNullableWithAggregatesFilter<"personalisation"> | string | null
  facial_hair_types?: Prisma.StringNullableWithAggregatesFilter<"personalisation"> | string | null
  facial_hair_colors?: Prisma.StringNullableWithAggregatesFilter<"personalisation"> | string | null
  clothes?: Prisma.StringNullableWithAggregatesFilter<"personalisation"> | string | null
  clothes_colors?: Prisma.StringNullableWithAggregatesFilter<"personalisation"> | string | null
  graphics?: Prisma.StringNullableWithAggregatesFilter<"personalisation"> | string | null
  eyes?: Prisma.StringNullableWithAggregatesFilter<"personalisation"> | string | null
  eyebrows?: Prisma.StringNullableWithAggregatesFilter<"personalisation"> | string | null
  skin_colors?: Prisma.StringNullableWithAggregatesFilter<"personalisation"> | string | null
}

export type personalisationCreateInput = {
  accessories?: string | null
  hat_colors?: string | null
  hair_colors?: string | null
  facial_hair_types?: string | null
  facial_hair_colors?: string | null
  clothes?: string | null
  clothes_colors?: string | null
  graphics?: string | null
  eyes?: string | null
  eyebrows?: string | null
  skin_colors?: string | null
  user: Prisma.userCreateNestedOneWithoutPersonalisationInput
}

export type personalisationUncheckedCreateInput = {
  id_user: string
  accessories?: string | null
  hat_colors?: string | null
  hair_colors?: string | null
  facial_hair_types?: string | null
  facial_hair_colors?: string | null
  clothes?: string | null
  clothes_colors?: string | null
  graphics?: string | null
  eyes?: string | null
  eyebrows?: string | null
  skin_colors?: string | null
}

export type personalisationUpdateInput = {
  accessories?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hat_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_types?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  graphics?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyebrows?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  skin_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  user?: Prisma.userUpdateOneRequiredWithoutPersonalisationNestedInput
}

export type personalisationUncheckedUpdateInput = {
  id_user?: Prisma.StringFieldUpdateOperationsInput | string
  accessories?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hat_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_types?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  graphics?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyebrows?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  skin_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type personalisationCreateManyInput = {
  id_user: string
  accessories?: string | null
  hat_colors?: string | null
  hair_colors?: string | null
  facial_hair_types?: string | null
  facial_hair_colors?: string | null
  clothes?: string | null
  clothes_colors?: string | null
  graphics?: string | null
  eyes?: string | null
  eyebrows?: string | null
  skin_colors?: string | null
}

export type personalisationUpdateManyMutationInput = {
  accessories?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hat_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_types?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  graphics?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyebrows?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  skin_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type personalisationUncheckedUpdateManyInput = {
  id_user?: Prisma.StringFieldUpdateOperationsInput | string
  accessories?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hat_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_types?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  graphics?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyebrows?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  skin_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type personalisationOrderByRelevanceInput = {
  fields: Prisma.personalisationOrderByRelevanceFieldEnum | Prisma.personalisationOrderByRelevanceFieldEnum[]
  sort: Prisma.SortOrder
  search: string
}

export type personalisationCountOrderByAggregateInput = {
  id_user?: Prisma.SortOrder
  accessories?: Prisma.SortOrder
  hat_colors?: Prisma.SortOrder
  hair_colors?: Prisma.SortOrder
  facial_hair_types?: Prisma.SortOrder
  facial_hair_colors?: Prisma.SortOrder
  clothes?: Prisma.SortOrder
  clothes_colors?: Prisma.SortOrder
  graphics?: Prisma.SortOrder
  eyes?: Prisma.SortOrder
  eyebrows?: Prisma.SortOrder
  skin_colors?: Prisma.SortOrder
}

export type personalisationMaxOrderByAggregateInput = {
  id_user?: Prisma.SortOrder
  accessories?: Prisma.SortOrder
  hat_colors?: Prisma.SortOrder
  hair_colors?: Prisma.SortOrder
  facial_hair_types?: Prisma.SortOrder
  facial_hair_colors?: Prisma.SortOrder
  clothes?: Prisma.SortOrder
  clothes_colors?: Prisma.SortOrder
  graphics?: Prisma.SortOrder
  eyes?: Prisma.SortOrder
  eyebrows?: Prisma.SortOrder
  skin_colors?: Prisma.SortOrder
}

export type personalisationMinOrderByAggregateInput = {
  id_user?: Prisma.SortOrder
  accessories?: Prisma.SortOrder
  hat_colors?: Prisma.SortOrder
  hair_colors?: Prisma.SortOrder
  facial_hair_types?: Prisma.SortOrder
  facial_hair_colors?: Prisma.SortOrder
  clothes?: Prisma.SortOrder
  clothes_colors?: Prisma.SortOrder
  graphics?: Prisma.SortOrder
  eyes?: Prisma.SortOrder
  eyebrows?: Prisma.SortOrder
  skin_colors?: Prisma.SortOrder
}

export type PersonalisationNullableScalarRelationFilter = {
  is?: Prisma.personalisationWhereInput | null
  isNot?: Prisma.personalisationWhereInput | null
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
}

export type personalisationCreateNestedOneWithoutUserInput = {
  create?: Prisma.XOR<Prisma.personalisationCreateWithoutUserInput, Prisma.personalisationUncheckedCreateWithoutUserInput>
  connectOrCreate?: Prisma.personalisationCreateOrConnectWithoutUserInput
  connect?: Prisma.personalisationWhereUniqueInput
}

export type personalisationUncheckedCreateNestedOneWithoutUserInput = {
  create?: Prisma.XOR<Prisma.personalisationCreateWithoutUserInput, Prisma.personalisationUncheckedCreateWithoutUserInput>
  connectOrCreate?: Prisma.personalisationCreateOrConnectWithoutUserInput
  connect?: Prisma.personalisationWhereUniqueInput
}

export type personalisationUpdateOneWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.personalisationCreateWithoutUserInput, Prisma.personalisationUncheckedCreateWithoutUserInput>
  connectOrCreate?: Prisma.personalisationCreateOrConnectWithoutUserInput
  upsert?: Prisma.personalisationUpsertWithoutUserInput
  disconnect?: Prisma.personalisationWhereInput | boolean
  delete?: Prisma.personalisationWhereInput | boolean
  connect?: Prisma.personalisationWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.personalisationUpdateToOneWithWhereWithoutUserInput, Prisma.personalisationUpdateWithoutUserInput>, Prisma.personalisationUncheckedUpdateWithoutUserInput>
}

export type personalisationUncheckedUpdateOneWithoutUserNestedInput = {
  create?: Prisma.XOR<Prisma.personalisationCreateWithoutUserInput, Prisma.personalisationUncheckedCreateWithoutUserInput>
  connectOrCreate?: Prisma.personalisationCreateOrConnectWithoutUserInput
  upsert?: Prisma.personalisationUpsertWithoutUserInput
  disconnect?: Prisma.personalisationWhereInput | boolean
  delete?: Prisma.personalisationWhereInput | boolean
  connect?: Prisma.personalisationWhereUniqueInput
  update?: Prisma.XOR<Prisma.XOR<Prisma.personalisationUpdateToOneWithWhereWithoutUserInput, Prisma.personalisationUpdateWithoutUserInput>, Prisma.personalisationUncheckedUpdateWithoutUserInput>
}

export type personalisationCreateWithoutUserInput = {
  accessories?: string | null
  hat_colors?: string | null
  hair_colors?: string | null
  facial_hair_types?: string | null
  facial_hair_colors?: string | null
  clothes?: string | null
  clothes_colors?: string | null
  graphics?: string | null
  eyes?: string | null
  eyebrows?: string | null
  skin_colors?: string | null
}

export type personalisationUncheckedCreateWithoutUserInput = {
  accessories?: string | null
  hat_colors?: string | null
  hair_colors?: string | null
  facial_hair_types?: string | null
  facial_hair_colors?: string | null
  clothes?: string | null
  clothes_colors?: string | null
  graphics?: string | null
  eyes?: string | null
  eyebrows?: string | null
  skin_colors?: string | null
}

export type personalisationCreateOrConnectWithoutUserInput = {
  where: Prisma.personalisationWhereUniqueInput
  create: Prisma.XOR<Prisma.personalisationCreateWithoutUserInput, Prisma.personalisationUncheckedCreateWithoutUserInput>
}

export type personalisationUpsertWithoutUserInput = {
  update: Prisma.XOR<Prisma.personalisationUpdateWithoutUserInput, Prisma.personalisationUncheckedUpdateWithoutUserInput>
  create: Prisma.XOR<Prisma.personalisationCreateWithoutUserInput, Prisma.personalisationUncheckedCreateWithoutUserInput>
  where?: Prisma.personalisationWhereInput
}

export type personalisationUpdateToOneWithWhereWithoutUserInput = {
  where?: Prisma.personalisationWhereInput
  data: Prisma.XOR<Prisma.personalisationUpdateWithoutUserInput, Prisma.personalisationUncheckedUpdateWithoutUserInput>
}

export type personalisationUpdateWithoutUserInput = {
  accessories?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hat_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_types?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  graphics?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyebrows?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  skin_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}

export type personalisationUncheckedUpdateWithoutUserInput = {
  accessories?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hat_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_types?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  facial_hair_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  clothes_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  graphics?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyes?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  eyebrows?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
  skin_colors?: Prisma.NullableStringFieldUpdateOperationsInput | string | null
}



export type personalisationSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id_user?: boolean
  accessories?: boolean
  hat_colors?: boolean
  hair_colors?: boolean
  facial_hair_types?: boolean
  facial_hair_colors?: boolean
  clothes?: boolean
  clothes_colors?: boolean
  graphics?: boolean
  eyes?: boolean
  eyebrows?: boolean
  skin_colors?: boolean
  user?: boolean | Prisma.userDefaultArgs<ExtArgs>
}, ExtArgs["result"]["personalisation"]>



export type personalisationSelectScalar = {
  id_user?: boolean
  accessories?: boolean
  hat_colors?: boolean
  hair_colors?: boolean
  facial_hair_types?: boolean
  facial_hair_colors?: boolean
  clothes?: boolean
  clothes_colors?: boolean
  graphics?: boolean
  eyes?: boolean
  eyebrows?: boolean
  skin_colors?: boolean
}

export type personalisationOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id_user" | "accessories" | "hat_colors" | "hair_colors" | "facial_hair_types" | "facial_hair_colors" | "clothes" | "clothes_colors" | "graphics" | "eyes" | "eyebrows" | "skin_colors", ExtArgs["result"]["personalisation"]>
export type personalisationInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  user?: boolean | Prisma.userDefaultArgs<ExtArgs>
}

export type $personalisationPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "personalisation"
  objects: {
    user: Prisma.$userPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id_user: string
    accessories: string | null
    hat_colors: string | null
    hair_colors: string | null
    facial_hair_types: string | null
    facial_hair_colors: string | null
    clothes: string | null
    clothes_colors: string | null
    graphics: string | null
    eyes: string | null
    eyebrows: string | null
    skin_colors: string | null
  }, ExtArgs["result"]["personalisation"]>
  composites: {}
}

export type personalisationGetPayload<S extends boolean | null | undefined | personalisationDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$personalisationPayload, S>

export type personalisationCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<personalisationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PersonalisationCountAggregateInputType | true
  }

export interface personalisationDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['personalisation'], meta: { name: 'personalisation' } }
  /**
   * Find zero or one Personalisation that matches the filter.
   * @param {personalisationFindUniqueArgs} args - Arguments to find a Personalisation
   * @example
   * // Get one Personalisation
   * const personalisation = await prisma.personalisation.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends personalisationFindUniqueArgs>(args: Prisma.SelectSubset<T, personalisationFindUniqueArgs<ExtArgs>>): Prisma.Prisma__personalisationClient<runtime.Types.Result.GetResult<Prisma.$personalisationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Personalisation that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {personalisationFindUniqueOrThrowArgs} args - Arguments to find a Personalisation
   * @example
   * // Get one Personalisation
   * const personalisation = await prisma.personalisation.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends personalisationFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, personalisationFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__personalisationClient<runtime.Types.Result.GetResult<Prisma.$personalisationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Personalisation that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {personalisationFindFirstArgs} args - Arguments to find a Personalisation
   * @example
   * // Get one Personalisation
   * const personalisation = await prisma.personalisation.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends personalisationFindFirstArgs>(args?: Prisma.SelectSubset<T, personalisationFindFirstArgs<ExtArgs>>): Prisma.Prisma__personalisationClient<runtime.Types.Result.GetResult<Prisma.$personalisationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Personalisation that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {personalisationFindFirstOrThrowArgs} args - Arguments to find a Personalisation
   * @example
   * // Get one Personalisation
   * const personalisation = await prisma.personalisation.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends personalisationFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, personalisationFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__personalisationClient<runtime.Types.Result.GetResult<Prisma.$personalisationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Personalisations that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {personalisationFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Personalisations
   * const personalisations = await prisma.personalisation.findMany()
   * 
   * // Get first 10 Personalisations
   * const personalisations = await prisma.personalisation.findMany({ take: 10 })
   * 
   * // Only select the `id_user`
   * const personalisationWithId_userOnly = await prisma.personalisation.findMany({ select: { id_user: true } })
   * 
   */
  findMany<T extends personalisationFindManyArgs>(args?: Prisma.SelectSubset<T, personalisationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$personalisationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Personalisation.
   * @param {personalisationCreateArgs} args - Arguments to create a Personalisation.
   * @example
   * // Create one Personalisation
   * const Personalisation = await prisma.personalisation.create({
   *   data: {
   *     // ... data to create a Personalisation
   *   }
   * })
   * 
   */
  create<T extends personalisationCreateArgs>(args: Prisma.SelectSubset<T, personalisationCreateArgs<ExtArgs>>): Prisma.Prisma__personalisationClient<runtime.Types.Result.GetResult<Prisma.$personalisationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Personalisations.
   * @param {personalisationCreateManyArgs} args - Arguments to create many Personalisations.
   * @example
   * // Create many Personalisations
   * const personalisation = await prisma.personalisation.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends personalisationCreateManyArgs>(args?: Prisma.SelectSubset<T, personalisationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Delete a Personalisation.
   * @param {personalisationDeleteArgs} args - Arguments to delete one Personalisation.
   * @example
   * // Delete one Personalisation
   * const Personalisation = await prisma.personalisation.delete({
   *   where: {
   *     // ... filter to delete one Personalisation
   *   }
   * })
   * 
   */
  delete<T extends personalisationDeleteArgs>(args: Prisma.SelectSubset<T, personalisationDeleteArgs<ExtArgs>>): Prisma.Prisma__personalisationClient<runtime.Types.Result.GetResult<Prisma.$personalisationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Personalisation.
   * @param {personalisationUpdateArgs} args - Arguments to update one Personalisation.
   * @example
   * // Update one Personalisation
   * const personalisation = await prisma.personalisation.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends personalisationUpdateArgs>(args: Prisma.SelectSubset<T, personalisationUpdateArgs<ExtArgs>>): Prisma.Prisma__personalisationClient<runtime.Types.Result.GetResult<Prisma.$personalisationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Personalisations.
   * @param {personalisationDeleteManyArgs} args - Arguments to filter Personalisations to delete.
   * @example
   * // Delete a few Personalisations
   * const { count } = await prisma.personalisation.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends personalisationDeleteManyArgs>(args?: Prisma.SelectSubset<T, personalisationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Personalisations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {personalisationUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Personalisations
   * const personalisation = await prisma.personalisation.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends personalisationUpdateManyArgs>(args: Prisma.SelectSubset<T, personalisationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create or update one Personalisation.
   * @param {personalisationUpsertArgs} args - Arguments to update or create a Personalisation.
   * @example
   * // Update or create a Personalisation
   * const personalisation = await prisma.personalisation.upsert({
   *   create: {
   *     // ... data to create a Personalisation
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Personalisation we want to update
   *   }
   * })
   */
  upsert<T extends personalisationUpsertArgs>(args: Prisma.SelectSubset<T, personalisationUpsertArgs<ExtArgs>>): Prisma.Prisma__personalisationClient<runtime.Types.Result.GetResult<Prisma.$personalisationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Personalisations.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {personalisationCountArgs} args - Arguments to filter Personalisations to count.
   * @example
   * // Count the number of Personalisations
   * const count = await prisma.personalisation.count({
   *   where: {
   *     // ... the filter for the Personalisations we want to count
   *   }
   * })
  **/
  count<T extends personalisationCountArgs>(
    args?: Prisma.Subset<T, personalisationCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], PersonalisationCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Personalisation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {PersonalisationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends PersonalisationAggregateArgs>(args: Prisma.Subset<T, PersonalisationAggregateArgs>): Prisma.PrismaPromise<GetPersonalisationAggregateType<T>>

  /**
   * Group by Personalisation.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {personalisationGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends personalisationGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: personalisationGroupByArgs['orderBy'] }
      : { orderBy?: personalisationGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, personalisationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalisationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the personalisation model
 */
readonly fields: personalisationFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for personalisation.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__personalisationClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  user<T extends Prisma.userDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.userDefaultArgs<ExtArgs>>): Prisma.Prisma__userClient<runtime.Types.Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the personalisation model
 */
export interface personalisationFieldRefs {
  readonly id_user: Prisma.FieldRef<"personalisation", 'String'>
  readonly accessories: Prisma.FieldRef<"personalisation", 'String'>
  readonly hat_colors: Prisma.FieldRef<"personalisation", 'String'>
  readonly hair_colors: Prisma.FieldRef<"personalisation", 'String'>
  readonly facial_hair_types: Prisma.FieldRef<"personalisation", 'String'>
  readonly facial_hair_colors: Prisma.FieldRef<"personalisation", 'String'>
  readonly clothes: Prisma.FieldRef<"personalisation", 'String'>
  readonly clothes_colors: Prisma.FieldRef<"personalisation", 'String'>
  readonly graphics: Prisma.FieldRef<"personalisation", 'String'>
  readonly eyes: Prisma.FieldRef<"personalisation", 'String'>
  readonly eyebrows: Prisma.FieldRef<"personalisation", 'String'>
  readonly skin_colors: Prisma.FieldRef<"personalisation", 'String'>
}
    

// Custom InputTypes
/**
 * personalisation findUnique
 */
export type personalisationFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the personalisation
   */
  select?: Prisma.personalisationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the personalisation
   */
  omit?: Prisma.personalisationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.personalisationInclude<ExtArgs> | null
  /**
   * Filter, which personalisation to fetch.
   */
  where: Prisma.personalisationWhereUniqueInput
}

/**
 * personalisation findUniqueOrThrow
 */
export type personalisationFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the personalisation
   */
  select?: Prisma.personalisationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the personalisation
   */
  omit?: Prisma.personalisationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.personalisationInclude<ExtArgs> | null
  /**
   * Filter, which personalisation to fetch.
   */
  where: Prisma.personalisationWhereUniqueInput
}

/**
 * personalisation findFirst
 */
export type personalisationFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the personalisation
   */
  select?: Prisma.personalisationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the personalisation
   */
  omit?: Prisma.personalisationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.personalisationInclude<ExtArgs> | null
  /**
   * Filter, which personalisation to fetch.
   */
  where?: Prisma.personalisationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of personalisations to fetch.
   */
  orderBy?: Prisma.personalisationOrderByWithRelationInput | Prisma.personalisationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for personalisations.
   */
  cursor?: Prisma.personalisationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` personalisations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` personalisations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of personalisations.
   */
  distinct?: Prisma.PersonalisationScalarFieldEnum | Prisma.PersonalisationScalarFieldEnum[]
}

/**
 * personalisation findFirstOrThrow
 */
export type personalisationFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the personalisation
   */
  select?: Prisma.personalisationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the personalisation
   */
  omit?: Prisma.personalisationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.personalisationInclude<ExtArgs> | null
  /**
   * Filter, which personalisation to fetch.
   */
  where?: Prisma.personalisationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of personalisations to fetch.
   */
  orderBy?: Prisma.personalisationOrderByWithRelationInput | Prisma.personalisationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for personalisations.
   */
  cursor?: Prisma.personalisationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` personalisations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` personalisations.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of personalisations.
   */
  distinct?: Prisma.PersonalisationScalarFieldEnum | Prisma.PersonalisationScalarFieldEnum[]
}

/**
 * personalisation findMany
 */
export type personalisationFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the personalisation
   */
  select?: Prisma.personalisationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the personalisation
   */
  omit?: Prisma.personalisationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.personalisationInclude<ExtArgs> | null
  /**
   * Filter, which personalisations to fetch.
   */
  where?: Prisma.personalisationWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of personalisations to fetch.
   */
  orderBy?: Prisma.personalisationOrderByWithRelationInput | Prisma.personalisationOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing personalisations.
   */
  cursor?: Prisma.personalisationWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` personalisations from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` personalisations.
   */
  skip?: number
  distinct?: Prisma.PersonalisationScalarFieldEnum | Prisma.PersonalisationScalarFieldEnum[]
}

/**
 * personalisation create
 */
export type personalisationCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the personalisation
   */
  select?: Prisma.personalisationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the personalisation
   */
  omit?: Prisma.personalisationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.personalisationInclude<ExtArgs> | null
  /**
   * The data needed to create a personalisation.
   */
  data: Prisma.XOR<Prisma.personalisationCreateInput, Prisma.personalisationUncheckedCreateInput>
}

/**
 * personalisation createMany
 */
export type personalisationCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many personalisations.
   */
  data: Prisma.personalisationCreateManyInput | Prisma.personalisationCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * personalisation update
 */
export type personalisationUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the personalisation
   */
  select?: Prisma.personalisationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the personalisation
   */
  omit?: Prisma.personalisationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.personalisationInclude<ExtArgs> | null
  /**
   * The data needed to update a personalisation.
   */
  data: Prisma.XOR<Prisma.personalisationUpdateInput, Prisma.personalisationUncheckedUpdateInput>
  /**
   * Choose, which personalisation to update.
   */
  where: Prisma.personalisationWhereUniqueInput
}

/**
 * personalisation updateMany
 */
export type personalisationUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update personalisations.
   */
  data: Prisma.XOR<Prisma.personalisationUpdateManyMutationInput, Prisma.personalisationUncheckedUpdateManyInput>
  /**
   * Filter which personalisations to update
   */
  where?: Prisma.personalisationWhereInput
  /**
   * Limit how many personalisations to update.
   */
  limit?: number
}

/**
 * personalisation upsert
 */
export type personalisationUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the personalisation
   */
  select?: Prisma.personalisationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the personalisation
   */
  omit?: Prisma.personalisationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.personalisationInclude<ExtArgs> | null
  /**
   * The filter to search for the personalisation to update in case it exists.
   */
  where: Prisma.personalisationWhereUniqueInput
  /**
   * In case the personalisation found by the `where` argument doesn't exist, create a new personalisation with this data.
   */
  create: Prisma.XOR<Prisma.personalisationCreateInput, Prisma.personalisationUncheckedCreateInput>
  /**
   * In case the personalisation was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.personalisationUpdateInput, Prisma.personalisationUncheckedUpdateInput>
}

/**
 * personalisation delete
 */
export type personalisationDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the personalisation
   */
  select?: Prisma.personalisationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the personalisation
   */
  omit?: Prisma.personalisationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.personalisationInclude<ExtArgs> | null
  /**
   * Filter which personalisation to delete.
   */
  where: Prisma.personalisationWhereUniqueInput
}

/**
 * personalisation deleteMany
 */
export type personalisationDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which personalisations to delete
   */
  where?: Prisma.personalisationWhereInput
  /**
   * Limit how many personalisations to delete.
   */
  limit?: number
}

/**
 * personalisation without action
 */
export type personalisationDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the personalisation
   */
  select?: Prisma.personalisationSelect<ExtArgs> | null
  /**
   * Omit specific fields from the personalisation
   */
  omit?: Prisma.personalisationOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.personalisationInclude<ExtArgs> | null
}
